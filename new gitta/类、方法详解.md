[toc]

## 类与方法详解

/**此篇文档为java代码的详细分析

*用来小组成员们看的哟

*为了方便，这篇文档的注释不按规范写啦

*/

@author：java18小组

### ==A.主类（Main)==

<img src="/Users/caocan/Library/Application Support/typora-user-images/image-20210110172848675.png" alt="image-20210110172848675" style="zoom:35%;" />

用于分析命令行参数启动Gitta对象实现命令行要求

#### 方法

##### 1.main():

- 分析命令行参数并解决错误
- 检核是否合规
- 根据参数<u>调用repository的静态方法</u>

##### 代码详解

```java
public class Main {

    /** 目前工作目录*/
    static final File CWD = new File(".");

    /** 用法: java gitta.Main 字符串数组, 字符串数组由以下成份组成
     *  <命令> <操作数> .... */
    public static void main(String... args) {
        if (args.length == 0) {  //如果命令行为空，提示以下
            System.out.print("Please enter a command.");
            System.exit(0);
        }

        try { //我们传入的字符串数组第一个字符串对应哪种命令，就调用main里面的相应函数
            switch (args[0]) { //字符串数组里的第一个字符串
            case "init":
                init(args); //传入字符串数组，调用main里的init方法，即41行
                break;
            case "add":
                add(args); //同上，调用main里的add方法
                break;
      ……//省略
            case "rm-branch":
                rmBranch(args);
                break;
            case "reset":
                reset(args);
                break;
            case "merge":
                merge(args);
                break;
            default: //第一个字符串不是以上的命令下，输出以下内容
                System.out.print("No command with that name exists.");
            }
        } catch (GitletException e) {
            System.out.print(e.getMsg());//获取异常的详细消息字符串
        }
        System.exit(0);
    }
  
    private static void init(String[] args) {//被17行 init(args)调用
        operandsCheck(args, 1, 0);//调用main里的operandsCheck方法
        validateRepoExist(false);//调用main里的validateRepoExist方法85行
        Repository.init();//调用Repository类的静态方法init()
    }

    private static void add(String[] args) {//同上
        operandsCheck(args, 1, 1);//方法具体是什么，参数为什么这样给，方法那里写
        validateRepoExist(true);
        Repository.add(validateFileExist(args, 1));
    }
……//省略
    private static void checkout(String[] args) {//checkout命令行的三种用法
        if (args.length == 3 && args[1].equals("--")) {//但这个我们不要了
            validateRepoExist(true);
            Repository.checkoutFile(args[2]);
        } else if (args.length == 4 && args[2].equals("--")) {//这个也不要了
            validateRepoExist(true);
            Repository.checkoutFileWithID(args[3], args[1]);
        } else {
            operandsCheck(args, 2, 0);//保留这个，就是切换到新分支上
            validateRepoExist(true);
            Repository.checkoutBranch(args[1]);
        }
    }
    /**operandCheck方法
     * 核对输入进来的操作数
     * @参数：输入进来的字符串数组
     * @参数：期望的操作数
     * @参数： type =0 等于, >0 多于, <0 少于
     *比如：对于切换新分支 &checkout newbranch 里是operandsCheck(args, 2, 0);
     *意思是：expected=2（我期望输入的字符串数组是checkout newbranch，即length为2）
     *type=0是我要求你必须是length=2
     */
    private static void operandsCheck(String[] args, int expected, int type) {
        if ((type > 0 && args.length <= expected)//要求正确输入是多于期望，但却<=
            || (type == 0 && args.length != expected)//正确输入是等于期望，但却！=
            || (type < 0 && args.length >= expected)) {//正确输入是小于期望，但却>=
            System.out.print("Incorrect operands.");//有以上情况输出此内容
            System.exit(0);
        }
    }
  //下面是几个Validate方法
    /**ValidateReopoExist方法
     * 检查仓库是否存在
     * @参数 验证存在为true, 否则为false
     */
    private static void validateRepoExist(boolean expected) {
        if (Repository.isExisted() != expected) {//如果repository存在性和期待的不一样
            if (expected) {//期待仓库Repository是有的，却没有
             //即你还没init初始化就命令行输入别的操作了 
                System.out.print("Not in an initialized Gitlet directory");//则输出
                System.exit(0);
            } else {//期待仓库是空的，却不是空的
              //即你已经init过了，有repository了却又init时输出下列句子
                System.out.print("A Gitlet version-control system"
                    + "already exists in the current directory.");
                System.exit(0);
            }
        }
    }
    /** 检查验证暂存区是否为空*/
    private static void validateStageEmpty() {
        if (Stage.getStage().isEmpty()) {//暂存区为空
          //没有可以commit的暂存区内容
            System.out.print("No changes added to the commit.");
            System.exit(0);
        }
    }
    /**
     * 检查验证commit的附加消息是否为空
     */
    private static void validateMSG(String msg) {
        assert msg != null;
        if (msg.trim().equals("")) {//commit的时候没有输入备注消息，则输出以下
            System.out.print("Please enter a commit message");
            System.exit(0);
        }
    }
    /**
     * 验证检查文件是否存在，只被add方法调用
     * @参数：输入的字符串数组
     * @参数：偏移量，add的时候次参数为1，意思是我们输入$java gitta.Main add a.txt b.txt的时候，不管第一个字符“add”，从“a.txt”开始创建文件对象组成列表调用Repository的add方法
     * @返回现存的List<File>
     */
    private static List<File> validateFileExist(String[] args, int offset) {
        ArrayList<File> files = new ArrayList<>();//建立数组列表
        for (int i = offset; i < args.length; i += 1) {
            File f = Utils.join(CWD, args[i]);//新建File对象：当前工作目录下的这个文件
            if (!f.exists()) {//如果这个文件不存子啊，输出如下
                System.out.print("File does not exist.");
                System.exit(0);
            }
            files.add(f);//往数组列表中添加这个f文件对象
        }
        return files;//遍历完返回这个文件组成的列表
    }

}
```

### ==B.Repository class：==

<img src="/Users/caocan/Library/Application Support/typora-user-images/image-20210110214416392.png" alt="image-20210110214416392" style="zoom:33%;" />

**当前工作目录下，操控所有操作**

- 数据域解释

  1.`File CWD` 当前工作目录

  2.`FIle REPO_FOLDER`静态文件对象指向`.gitta`文件夹

  3.`File HEAD_PATH` 头文件路径，即`.gitta/head`文件，内容为当前所指分支

  4.`_reference` 当前仓库信息

  5.`_head`当前仓库的分支名

  6.`_lastCommit`最新一次的Commit

  7.`_Stage`当前仓库的暂存区

#### 方法

 ##### 1.init():

```java
 public static void init() throws GitletException {
        assert !isExisted();//断言.gitta文件夹存在
        if (!REPO_FOLDER.mkdir()) {//初始化创建.gitta失败，输出如下
            throw new GitletException("Failed to init repository.");
        }
        Stage.init();//初始化Stage，调用Stage的init方法
        Reference.init();//初始化Reference，调用Reference的init方法
        Utils.writeContents(HEAD_PATH, "master");//使用Utils工具类向.gitta/head文件中写入初始化的分支master分支
    }
```

##### 2.add():

==我们的亮点之一==

```java
 public static void add(List<File> files) {//前面main方法里会让java gitta.Main add a.txt b.txt……的文件新建file对象形成一个List来调用这个方法
        for (File file : files) {//遍历里面每个文件
            String sha1 = new Blob(file).getSha1();//每个文件生成一个新的Blob并得到sha1
            if (_lastCommit.containsFile(file)//如果上一次的commit中有这个文件
                && _lastCommit.getBlobId(file).equals(sha1)) {//并且上一次commit这个文件后sha1值未发现改变，即文件未修改
                if (_stage.isFileStaged(file)) {//并且这个文件出现在暂存区
                    _stage.unstagedFile(file);//把这个文件从暂存区移走
                }
                if (_stage.isFileRemoved(file)) {//如果这个文件是已经删去的文件
                    _stage.unremovedFile(file);//从已删除中取出
                }
            } else {//上次的commit中没有出现过这个文件或者出现过但sha1值已经发生改变
                _stage.addFile(file);//暂存区加入此文件
                _stage.save();//调用stage的save方法将此文件对象写入到index文件中
            }
        }
    }
```

- 获取_lastCommit的objects
- 比较目前文件的SHA-1值和在_lastCommit中已有的Objects对象的SHA-1值
  - 如果一样，并且是与暂存区的文件一样，则尝试从stagedFiles（暂存文件）中删除
  - 如果一样，并且是与已删除区域的文件一样，则尝试从删除中取出。
  - 如果不一样，则去掉旧的Objects，替换成新的值，并将stage存入到index文件中。

##### 3.commit():

```java
//把当前暂存区的文件commit，main方法那边调用的时候是Repository.commit(args[1],null)
//即我们一般$java gitta.Main commit "msg"的时候，只传来了“msg”，和null（没有secondParent）
public static void commit(String msg, String secondParentId) {
        Commit commit;
        if (secondParentId == null) {//如果没有secondParentId
            commit = new Commit(_lastCommit,//新建一个commit对象，调用对应的构造方法
                                _reference.getBranch(_head), msg);
        } else {
            commit = new Commit(_lastCommit,//有secondParent时的commit构造方法
                                _reference.getBranch(_head),
                                secondParentId, msg);
        }
        for (String name : _stage.getStagedFileNames()) {//暂存区文件遍历
            commit.commitFile(name, _stage.getBlob(name));//调用coomit的commitFile方法，这个方法往blob的hashmap中加入新的键值对，并往.gitta/objects/sha1的文件中写入此blob对象
        }
        for (String filename : _stage.getRemovedFiles()) {
            commit.removeFile(filename);//把这些文件从hashmap中移除
        }
        _stage.clear();//清空暂存区
        String commitId = commit.saveFile();//使用Utils工具类使commit对象得到子节数组的内容，内容取到sha1值后，将此commit写入到.gitta/commits里面并返回sha1值
        _reference.branchUpdate(_head, commitId);//指向了此分支的新commit
    }
```

##### 4.rm()

```java
public static void rm(File file) throws GitletException {
        if (_stage.isFileStaged(file)) {//如果文件在暂存区
            _stage.unstagedFile(file);//从暂存区移除
        } else if (_lastCommit.containsFile(file)) {//若上次commit有此文件
            _stage.addRemovedFile(file);//删除文件添加到removed files区域
            if (!removeFile(file)) {//如果无法成功删除则输出下列内容
                throw new GittaException("Failed to remove file"
                                        + "from working directory");
            }
        } else {//其他情况输出以下
            throw new GittaException("No reason to remove the file");
        }
    }
```

- 如果文件已add，将文件从暂存区移到UntrackedFiles区域

- 如果文件已经commit，则删除工作目录的该文件，并将被删除的文件名添加到Removed Files区域

##### 5.log()

```java
    /** 打印当前分支的log. */
    public static void log() {
        String commitID = _reference.getBranch(_head); //取得当前分支的头commit
        Commit commit = Commit.getCommit(commitID);
        while (commit != null) {
            commit.printLog(commitID);//调用commit的printLog方法打印log，这里有个输出
            commitID = commit.getParentId();//逐层取commit的parent的id
            commit = Commit.getCommit(commitID);
        }
    }
```

- 从头引用读取构造的commit对象，打印相关信息

- 根据提commit object的parent ref往回遍历，直到初始commit

##### 6.global-log()

```java
 /**打印所有分支上的log. */
    public static void printAllLog() {
        Commit.printAllLog();//调用commit里的printAllLog方法
    }
    /** 找所有于msg对应的commit */
    public static void find(String msg) {//find方法
        List<String> commitIds = Commit.find(msg);//调用commit的find方法，找到的commitIds组成字符串列表
        if (commitIds.isEmpty()) {//没找到对应的commit则输出如下
            throw new GitletException("Found no commit with that message");
        }
        for (String id : commitIds) {//找到的在列表里，逐个输出
            System.out.println(id);
        }
    }
```

- 迭代所有commits，打印其相关信息。

##### <u>7.status()</u> 

<img src="/Users/caocan/Library/Application Support/typora-user-images/image-20210110230046308.png" alt="image-20210110230046308" style="zoom:50%;" />

==我们的亮点之二==

```java
/**打印当前仓库的状态信息 */
    public static void status() {
        printStatus("Branches", _reference.getBranchNames());//调用printStatus方法
        System.out.println();
        System.out.println();
        printStatus("Staged Files", _stage.getStagedFileNames());//get暂存区文件名字
        System.out.println();
        System.out.println();
        printStatus("Removed Files", _stage.getRemovedFileNames());//Removed Files
        System.out.println();
        System.out.println();
        printStatus("Modifications Not Staged For Commit",
                    getModifiedFileNames());
        System.out.println();
        System.out.println();
        printStatus("Untracked Files", getUntrackedFileNames());
        System.out.println();
    }
/**根据“Branches”等字符串参数*/
 private static void printStatus(String type, List<String> status) {//status组成列表
        System.out.print("=== " + type + " ===");//输出
        Collections.sort(status);//list里的名字自然排序
        for (String name : status) {//输出分支信息时，在当前的分支前加*号
            if (type.equals("Branches") && name.equals(_head)) {
                System.out.println();
                System.out.print("*" + name);
            } else {//其他的正常输出名字即可
                System.out.println();
                System.out.print(name);
            }
        }
    }
```

- 调用当前工作的Stage的方法打印相关信息

**8.checkout()**

````java
public static void checkoutBranch(String branch) throws GitletException {
        if (!_reference.containsBranch(branch)) {//没有此分支输出如下
            throw new GitletException("No such branch exists.");
        } else if (branch.equals(_head)) {//欲切换分支就是当前分支输出如下
            throw new GitletException("No need to checkout the current branch");
        }
        if (!isValidBranchCheckout(branch)) {//没有切换成功，因为当前commit下有untracked文件，并输出如下
            throw new GitletException("There is an untracked file in the way;"
                                   + " delete it, or add and commit it first");
        }
        checkoutCommit(_reference.getBranch(branch));//这个分支的最新commit中的文件用一个HashSet存储，当前工作区文件中有的而分支最新commit没有，则从当前工作区中删除。调用commit的恢复方法在当前工作目录上恢复这个分支的文件，并清空暂存区
        saveHead(branch);//切换分支把这个分支名写入到.gitta/head中
    }
````

- `checkout [branch name]` 切换分支
  - 由branchname得到它的最新commit对象，与当前工作目录最新分支比较，没有的Object删掉，其他的恢复到工作区
  - 保存到head文件中
  - 清空Stage

**9.branch()**

- 通过一个给定的branch名来调用`_reference.addBranch`方法来创建分支。

```java
 public static void branch(String branch) throws GitletException {
        checkBranchNotExist(branch);
        _reference.addBranch(branch, _reference.getBranch(_head));//调用reference的addBranch方法
    }
private static void checkBranchExist(String branch) {//检查分支是否存在
        if (!_reference.containsBranch(branch)) {//如果不存在输出如下
            throw new GitletException("A branch with that name"
                                    + "does not exist.");
        }
    }
private static void checkBranchNotExist(String branch) {
        if (_reference.containsBranch(branch)) {//想证实此分支不存在，若存在则输出如下
            throw new GitletException("A branch with that name"
                                        + "already exists.");
        }
    }
```

**10.rm-branch()**

确认被删除分支存在且不是主分支，删除指向分支的的reference

~~~java
public static void removeBranch(String branch) throws GitletException {
        checkBranchExist(branch);//确认分支存在
        if (_head.equals(branch)) {//如果此时就在想删除的分支上，输出如下
            throw new GitletException("Cannot remove the current branch.");
        }
        _reference.removeBranch(branch);//调用reference的removeBranch方法移除此分支
    }
~~~

**11.reset()**

根据输入的回滚的commit id修改HEAD的位置,即将HEAD指向的位置改变为对应的版本

- checkoutCommit(id)通过id返回一个commit对象，所有的Objects组成一个Hashset，与当前分支最新的Objects比较，没有的删掉，有的就恢复到工作目录上，并清空Stage
- 更新当前的commit-id，根据id修改分支名

~~~java
public static void reset(String id) throws GitletException {
        Commit commit = Commit.getCommit(id);//取id找到对应的commit
        if (commit == null) {//如果不存在此id的commit输出如下
            throw new GitletException("No commit with that id exists");
        }
        if (!isValidCommitCheckout(id)) {//若当前commit还有untreackedfiles输出如下
            throw new GitletException("There is an untracked file in the way;"
                                  + " delete it, or add and commit it first.");
        }
        checkoutCommit(id);//切换到此commit上
        _reference.branchUpdate(_head, id);//分支和id的更新
    }
~~~

==**12.merge()**==亮点内容

- 确认要merge的branch是否存在，确认此branch不是目前的分支
- 若splitID和branch最新commitid一致，则拟合并的branch即是当前的祖先
- 若splitID和目前分支一致，则需要目前分支fast-forward，使用chekoutCommit方法，将没有的Object实现在当前工作目录中
- 其余情况调用handleMerge方法，在没有冲突的情况下
  - 若分支修与lca相比修改过而当前分支未修改，直接在工作区和暂存区中生成这些文件
  - 若分支上有新文件而当前分支没有，处理同上行
  - 若当前分支与lca一致，所给分支有删除文件，则需要删除工作区的对应文件
- 其余情况需要处理冲突
  - 读取两个分支上的冲突文件内容，并按一定格式写入文件
- merge成功后生成新的commit对象，如果有处理冲突，输出有merge冲突的信息

```java
 public static void merge(String branch) throws GitletException {
        if (!_stage.isEmpty()) {//当前暂存区还有文件未commit输出如下
            throw new GitletException("You have uncommitted changes.");
        }
        checkBranchExist(branch);//确保要merge的分支是存在的
        validateNotHeadBranch(branch);//确保要merge的分支不是目前的分支
        String splitId = findLCA(branch);//找到LCA，即分支的最近祖先，也是分裂点
        String curId = _reference.getBranch(_head);//当前的commit
        String branchId = _reference.getBranch(branch);//分支的commit
        if (splitId.equals(branchId)) {//若分裂点与分支一致，输出如下，代表分支就是目前分支的祖先，不需要操作
            throw new GitletException("Given branch is an ancestor"
                                       + "of the current branch.");
        } else if (splitId.equals(curId)) {//当前点就是分裂点，即分支的commit领先于当前
            checkoutCommit(branchId);//fast-forward到最新的即可，输出如下
            throw new GitletException("Current branch fast-forwarded.");
        } else {//其他情况需要调用handleMerge方法来处理merge
            handleMerge(curId, branchId, splitId, branch);
        }
    }
//排除了一些特殊的情况后的merge方法
    private static void handleMerge(String curId,
                            String branchId, String splitId, String branch) {
        Commit lca = Commit.getCommit(splitId);//找到LCA，lac上的commitid
        Commit given = Commit.getCommit(branchId);//branch上的commitid
        boolean conflict = false;//判断两个分支是否冲突！！！
        for (String file : getUntrackedFileNames()) {
            if (given.containsFile(file)) {//若当前暂存区还有文件，输出如下
                throw new GitletException("There is an untracked file"
                + "in the way; delete it, or add and commit it first.");
            }
        }
      //当前分支最新提交的所有文件名组成hashset
        Set<String> files = new HashSet<>(_lastCommit.getBlobs().keySet());
        files.addAll(lca.getBlobs().keySet());//往set中放入lca的文件名
        files.addAll(given.getBlobs().keySet());//往set中放入分支的文件名
        for (String filename : files) {
            boolean givenModified = isModifiedSince(filename, given, lca);//自lca以来此分支有无修改这个文件
            boolean curModified = isModifiedSince(filename,
                                            _lastCommit, lca);//自lca以来当前分支有无修改这个文件
            boolean givenDeleted = isDeletedSince(filename, given, lca);
            boolean curDeleted = isDeletedSince(filename, _lastCommit, lca);
            boolean givenNew = isNewSince(filename, given, lca);//lca没有，分支上有无
            boolean curNew = isNewSince(filename, _lastCommit, lca);//lca没有，当前分支有无
            boolean curSame = isSameSince(filename, _lastCommit, lca);//都有且id相等与否
            if (givenModified && curSame) {//分支上修改了，当前分支与lca分支一样
                checkoutFileWithID(filename, branchId);
                _stage.addFile(Utils.join(CWD, filename));//加入分支的修改即可
            } else if (givenNew && !curNew) {//分支上新加了文件
                checkoutFileWithID(filename, branchId);
                _stage.addFile(Utils.join(CWD, filename));
            } else if (curSame && givenDeleted) {//分支上删了文件
                rm(Utils.join(CWD, filename));
              //冲突情况：
            } else if ((givenModified && curModified
                        && !branchId.equals(splitId))//都修改了一个文件且分支和分裂点不一致
                        || (givenModified && curDeleted)//分支上修改了，当前分支删除了
                        || (curModified && givenDeleted)//当前修改了，分支删除了
                        || (givenNew && curNew
                        && differentFile(branchId, curId))) {//分支上新建了，当前分支也新建了，并且不一样
                modifyConflictFile(filename, given);//调用解决冲突的函数
                _stage.addFile(Utils.join(CWD, filename));//往暂存区加文件
                conflict = true;//冲突
            }
        }
        _stage.save();//往index文件中写入对象
        commit("Merged " + branch + " into " + _head + ".", branchId);//调用commit构造方法，生成一个代表merge的新commit
        if (conflict) {//如果冲突了，输出如下
            System.out.print("Encountered a merge conflict.");
        }
    }
//冲突时修改文件如下
private static void modifyConflictFile(String filename, Commit commit) {
        Blob curBlob = _lastCommit.getBlob(filename);
        Blob otherBlob = commit.getBlob(filename);
        String newContent = "<<<<<<< HEAD"
                            + System.getProperty("line.separator", "\n");
        if (curBlob != null) {
            newContent += new String(curBlob.getContent(),
                            StandardCharsets.UTF_8);
        }
        newContent += "=======" + System.getProperty("line.separator", "\n");
        if (otherBlob != null) {
            newContent += new String(otherBlob.getContent(),
                                     StandardCharsets.UTF_8);
        }
        newContent += ">>>>>>>" + System.getProperty("line.separator", "\n");
        Utils.writeContents(Utils.join(CWD, filename), newContent);
    }
```

#### B.Reference class：

代表磁盘上的分支内容、commit内容

所有的分支名对应他们的SHA-1值

- 数据域

  1.`String REF_PATH ，即`.gitta/refs文件

  2.`HashMap _branches` 从分支名映射到SHA-1值

#### C.Stage class

此类用于管理仓库的暂存区

- 数据域
  1. `STAGE_FOLDER`stage文件夹的路径，即`.gitta/stafe`文件夹
  2. `INDEX_PATH`index文件的路径,即`.gitta/index` 文件
  3. `HashSet _removedFiles` 从删除的文件名映射到它们的ID
  4. `HashMap _stagedFiles` 从暂存的文件名映射到它们的ID
  5. `String STAGE_FOLDER` staged文件所在的文件夹
  6. `String INDEX_PATH` 索引文件的路径

#### D.Commit class

- 数据域

  1.`String _header` commi对象目前所在

  2.`String _parentId` 前次commit的key

  3.`String _secondParentId`

  4.`String _msg` commit的备注消息

  5.`HashMap _blobs` 将blob文件名映射到其SHA-1值

  6.`String _timestamp` 提交时间戳

  7.`File COMMITS_FOLDER` 提交对象所在的文件夹

#### E.Blob class

表示Blob对象在磁盘上的内容，路径：.gitlet / blob

- 数据域

  1.`File BLOBS_FOLDER` Blob文件所在的文件夹

  2.`String _header` Blob对象标头

  3.`Byte[] _content` Blob文件的内容。

